'''
x = [3804. 3485, 3261, 3022, 2871]
Gibt es echten Zufall?

Die Physiker sagen, etwa der radioaktive Zerfall sei
tatsächlich zufällig. Ich habe keine Ahnung, ob das 
stimmt. Tatsache aber ist, dass es praktisch nicht 
vorhersagbaren Zufall gibt, Münzwurf, Würfel, Roulett,
und so weiter und so fort. 

Aber die "Maschinen", die solchen Zufall produzieren, 
könnten manipuliert werden. Daher ist berechneter,
determinitischer Pseudozufall besser, wenn die Skripe
zur Berechnung des Zufalls überschaubar und daher leicht
verifizierbar sind. 

Schon relativ einfache interative Berechnungsmethoden 
(SPRITZ oder VMPC) liefern nahezu perfekten Zufall, der 
definitiv nicht vorhersagbar ist, falls der Anfangszustand
(SEED) nicht bekannt ist. Der Anfangszustand kann aus 
einem Passwort berechnet werden.

Die perfekte Verschlüsselung (One-Time-Pad), Zeichen
für Zeichen, mit einer Zufallszahl verschlüsselt, ist 
daher praktisch leicht realisierbar und praktisch 
100 Prozent sicher.

--------------------------------------------------------
EINSTEIN PODOLSKY ROSEN:

Es gibt echten Zufall. Dies ist kein Wiederspruch zur 
speziellen Relativitätstheorie, da bei Wechselwirkungen 
keine eindeutig gerichtete Ursache-Wirkung-Beziehung 
besteht. Durch die Umkehr der zeitlichen Abfolge von 
Ereignissen entsteht kein unmittelbarer logischer 
Widerspruch. 

Wären die Beobachtungen bei sogenannten verschränkten
Teilchen eindeutig vorausbestimmt, aus Eigenschaften 
der Teichen vor der Messung, wären die Gesetze der 
elementaren Logik verletzt. Es gibt die vermeintlich 
spukhafte Fernwirkung mit Überlichtgeschwingkeit, nicht 
nur in der Quantenmechanik, zum Beispiel auch bei der 
Gravitation.


   Sharpiro: Logisch - das Licht wird langsamer, denn 
   das Licht ist in der Materie tatsächlich langsamer. 
   
   Zwischen Erde und Sonne ist kein perfektes Vakuum. 
   
   (Licht := elektromagnetische Wellen)
   
 Zweiköperkörperproblem 
 --------------------------------------------- 
 Wir setzen voraus:
 
 Die Lösung (für gebundene Systeme) ist eine Ellipse:
 
 rmax/rmin = (Halbachse a) * (1 +/- epsilon) 
 
 a = (rmax + rmin)/2 
 epsilon = (rmax - rmin)/(rmin + rmax)

 Wir wollen Gesamtenergie (E < 0) und Drehimplus L 
 aus rmax/rmin berechen. Wir berechnen rmax/rmin, 
 indem wir die zeitliche Ableitung von r null setzen.
 
 Wir finden rmin/rmax als Lösung einer quadratischen
 Gleichung für r, wenn wir in 
 
 1/2 m v^2 - GMm/r - E = 0
 
 v = omega r, omega = L/m/r^2
 
 einsetzen und mit r^2 multiplizieren.

 Zur Erinnerung: (Mitternachtsgleichung ;))
 ----------------------
 A*x^2 + B*x + C = 0 
 x = - B/2A +/- sqrt (B^2 - 4AC)/2A 
 
 
 I.) 
 PLanet (Masse m) und die Sonne (Masse M)  
 A:= E
 B:= GMm
 C:= - (1/2*L^2/m)

 a = - B/2A = - GMm/2E

 E = - GMm/2a < 0

 epsilon = - sqrt((GMm)^2 + 2EL^2/m)/(2Ea)

=  sqrt((GMm)^2 + 2EL^2/m)/(GMm)

=  sqrt(1 + 2EL^2/m/(GMm)^2)

II.) 
 Elektron (Ladung -e, Masse m) und der Kern (Ladung e)  
 A:= E
 B:= (1/(4pi eps0) e^2
 C:= - (1/2*L^2/m)

 a(1 +/- epsilon) = - B/2A +/-sqrt(B^2 - 4*A*C)/2A

 a = - B/2A = - 1/(4pi eps0) e^2/2E

 E = - 1/(4pi eps0) e^2/2a  < 0

 epsilon = - sqrt((1/(4pi eps0) e^2)^2 + 2EL^2/m)/(2Ea)

=  sqrt((1/(4pi eps0) e^2)^2 + 2EL^2/m)/(1/(4pi eps0) e^2)

=  sqrt(1 + 2EL^2/m/(1/(4pi eps0) e^2)^2)

Das Elektron ist kein Punkt, aber es hat einen Schwerpunkt.
Warum sollten wir nicht mit dem Schwerpunkt rechnen können,
als bewege sich dieser um das Proton?

Hmmmm - wenn wir uns so ein Wasserstoffatom von außen 
ansehen, dann kann das aber irgendwie im Raum gegreht sein,
es kann sich als ganzes auch (langsam) drehen. Wir wissen
also nicht wirklich genau, wo sich das Elektron befindet
und letztlich nur eine Wahrscheinlichkeit bestimmen, es 
an einem Ort anzutreffen.

Jetzt nehmen wir doch einmal den Fall Drehimplus gleich null. 
In diesem Fall schwingt das Elektron mitten durch den Kern. 
Aber wir  wissen nicht in welche Richtung. Wir können nur 
ausrechnen, mit welcher Wahrscheinlichkeit es sich im Volumen 

(4pi r^2) dr 

befindet. Bei unveränderter Geschwindigkeit des Elektrons 
würde die Wahrscheinlichkeit mit 1/r^2 abnehmen. Da es sich 
in der Nähe des Kerns schneller bewegt, ist die Wahrschein-
lichkeit am Kernort geringer. Da jedoch die Ellipse sehr 
lang gestreckt ist, kann das Elektron im Grundzustand bis
zum doppelten Bohrradius hinausschwingen, aber nicht weiter! 

Diese Überlegungen stimmen fast mit den Vorhersagen der 
Quantenmechanik überein, allerdings nicht zu 100 Prozent.
Insbesondere gibt es nur für die Zustände mit Bahndrehimpuls
gleich null eine Wahrscheinlichkeit, dass sich das Elektron
im Kern befindet. Dies gilt aber auch nach Bohr-Sommerfeld.

Spontaner Zerfall und Zufall
----------------------------- 
Spontan heißt, eine unmittelbare Ursache ist nicht bekannt.
Ob es tatsächlich eine gibt, kann kein Mensch beantworten.
Wir können jedenfalls solche Zerfälle als Quelle "echten" 
Zufalls für die Kryptographie betrachten. 

Wir brauchen keine radioaktiven Zerfälle betrachten. Der 
Zerfall von elektronischen Anregungen reicht auch. Die 
Erzeugung von "echtem" Zufall für die Kryptographie ist 
nicht besonders schwierig. Messfehler und Manipultation
der Messgeräte müssen jedoch ausgeschlossen werden. Wir 
können natürlich auch eine Münze werfen oder würfeln.

Noch einfacher und schneller ist daher die Berechnung von
determinitischen, Pseudozufall, eigentlich überhautpt kein 
Problem.


ELLIPTISCHE KURVEN IN DER KRYPTOGRAPHIE
------------------------------------------------------ 
Wir beschränken uns auf einen einfachen Spezialfall:
   
   Falls p, (p+1) teilbar durch 4,
   p,(p+1)/4 zwei Primzahlen sind,
   dann liegen genau (p+1) Punkte auf der elliptischen
   Kurve inklusive dem virtuellen Punkt im Unendlichen.
   
   EC: y^2 = x^3 - x mod p 
   
   Dabei zählt auch der virtuelle Punkt im Unendlichen,
   das neutrale Element, als ein weiterer Punkt.
   
   Es ist total einfach - 
   hat aber scheinbar niemand verstanden.
   
   Sei G ein Punkt auf der Kurve und G, 2G, 3G und 4G
   ungleich dem Punkt im Unendlichen, dann ist die 
   Ordnung der Untergruppe zu dem Punkt G' := 4G die 
   Primzahl (p+1)/4. 
   
   Ist p > 2^160 (140 reicht eigentlich auch) ist alles 
   perfekt sicher. 
           
   Es ist alles ganz einfach, wir müssen es nur 
   richtig verstanden haben!
   
   Auch die Berechnung der Bewegung der 
   Himmelskörper erweist sich als im Grunde trivial.
   Dies gilt sogar dann, wenn wir die spezielle 
   Relativitätstheorie vollständig berücksichtigen.
   
   Der Clou - es gibt Computer, die für unsere Zwecke
   wahrhaft schnell genug und auch genau genug sind. Am 
   einfachsten wird es mit Python. 
   
   Wir rechnen ganz schlicht, Schrittchen für Schrittchen
   in ganz kleinen Zeitschritten dt, eine Sekunde oder 
   noch kürzer.
   
   Impulsänderung (dreidimensionaler Vektor) gleich 
   Kraft mal kleines Zeitinterval dt.
   
   Die Gesamtkraft auf einen Körper ist die Summe der 
   Kräfte aller übrigen Körper auf den betrachteten 
   Körper.
   
   Die Wechselwirkungskraft zwischen zwei Massen ergibt
   sich aus Newtons Gravitationsgesetz.
   
   Die Masse ist die relativitische Masse = Ruhemasse 
   durch Quadratwurzel aus (eins - Geschwindikeit durch 
   Lichtgeschwindigkeit im Quadrat).
   Aus dem Impuls ergibt sich die Änderung des Ortsvektors.
   
   x(t+dt) = x(t) + v_x(t) mal dt
   y(t+dt) = y(t) + v_y(t) mal dt
   z(t+dt) = z(t) + v_z(t) mal dt
   
   Kennen wir die Anfangswerte zu einem Zeitpunkt t0, 
   können alles weitere berechnen, jedenfalls genauer
   als wir messen können.
   
   Im Prinzip komplett simpel!
'''   
class ECHASH:
  def update(H):
    H.i = (H.i + H.w) % 256
    H.j = H.s[(H.j + H.s[H.i]) % 256]
    H.s[H.i], H.s[H.j] = H.s[H.j], H.s[H.i]

  def shuffle(H):
    for v in range(256):
        ECHASH.update(H)    
    H.w = (H.w + 2) % 256
    H.a = 0

  def absorb_nibble(H,x):
    if H.a == 63:
        ECHASH.shuffle(H)
    H.s[H.a], H.s[240 + x] = H.s[240 + x], H.s[H.a]
    H.a = H.a + 1

  def absorb_byte(H,b):
    ECHASH.absorb_nibble(H, b % 16)
    ECHASH.absorb_nibble(H, b >> 4)

  def h(H, msg, outlen):
    H.s = list(range(256))   
    H.a = H.i = H.j = 0
    H.w = 1
    for c in msg.encode():
       ECHASH.absorb_byte(H,c)
    ECHASH.shuffle(H)
    ECHASH.shuffle(H)
    ECHASH.shuffle(H)
    out = 0
    for v in range(outlen):
        ECHASH.update(H)
        out = (out << 8) + H.s[H.j]
    return out   

  def gcd(a,b):
    while b > 0:
      a,b = b,a % b
    return a

  def nextPrime(p):
    while p % 12 != 7:
      p = p + 1
    m =  5 * 7 * 11 * 13 * 17 * 19 * 23
    m *= 29 * 31 * 37 * 41 * 43 * 47
    while True:
      q = (p+1)//4
      x1 = ECHASH.gcd(p, m)
      x2 = ECHASH.gcd(q, m)
      while x1 != 1 or x2 != 1:
        p = p + 12 
        q = q + 3
        x1 = ECHASH.gcd(p, m)
        x2 = ECHASH.gcd(q, m)
      x1 = pow(7, p-1, p)    
      x2 = pow(7, q-1, q)    
      if (x1 != 1 or x2 != 1):
        p = p + 12
        continue
      return p
      
  def addP(P,Q):
    global ecc_a, ecc_prime     
    x1 = P[0]
    x2 = Q[0]
    y1 = P[1] 
    y2 = Q[1] 
    if x1 == x2:
       s = ((3*x1*x1 + ecc_a) * pow(2*y1, ecc_prime-2, 
       ecc_prime)) % ecc_prime
    else:  
       if x1 < x2:
          x1 = x1 + ecc_prime
       s = ((y1-y2) * pow(x1-x2, ecc_prime-2, 
       ecc_prime)) % ecc_prime
    xr =  (s*s) - x1 - x2
    yr = s * (x1-xr) - y1 
    return [xr % ecc_prime, yr % ecc_prime]

  def mulP(P,n):
    global ecc_prime     
    resP = 'ZERO'
    PP = P
    while n != 0:
       if (n % 2 != 0):   
         if resP == 'ZERO':
            resP = PP
         else:
            resP = ECHASH.addP(resP,PP)
       PP = ECHASH.addP(PP, PP) 
       n >>= 1 
    return resP

  def signSchnorr(G, m, x):
    global ecc_n     
    k = h('password X' + m + 'key value') 
    R = ECHASH.mulP(G,k) 
    e = h(str(R[0]) + m) % ecc_n
    return {'s': (k - x*e) % ecc_n, 'e': e}

  def ECDSA_N(G, m, x):
    global ecc_n     
    k = h('password X' + m + 'key value') 
    r = ECHASH.mulP(G,k)[0] % ecc_n     # the NONCE
    kinv = pow(k, ecc_n-2, ecc_n)
    z = h(m + str(r)) % ecc_n
    return {'s': (kinv*(z + x*r)) % ecc_n, 'r': r}
    
# 20 Bytes output like in SHA-1
def h(x):
  ha = ECHASH()
  return ECHASH.h(ha,x,20)     

maxx = 131 * 2**141
h0 = h('generate prime X')
ecc_prime = ECHASH.nextPrime( h0 % maxx )
''' Yes, the prime is large enough'''
print ("A prime greater than 2^141") 
print ("p = ", ecc_prime)
assert(ecc_prime > 2**141)

ecc_n = (ecc_prime + 1)//4
ecc_a = -1 
ecc_b = 0 
#
#               H I N G U C K E R
#
message = '''
Der Blickfang, Hingucker respektive Eyecatcher[1], 
ist in der Werbung und allen visuellen Medien ein 
Grafik- oder Text-Element, das die Aufmerksamkeit des
Betrachters auf eine bestimmte (Werbe-)Botschaft lenken
soll.[2] Als Blickfang werden Bilder oder Piktogramme, 
aber auch markante Slogans in auffälliger Typografie 
eingesetzt, die eine Orientierungsreaktion 
hin zur Erregung der Aufmerksamkeit erzielen wollen.

Wo ist dann das Teilchen?
Klar doch - überall wo das Feld nicht null ist!
Was ist dann eigentlich das Teilchen?
Im Grunde ist das Teilchen das Feld? :O
Doch - wir können auch die Ladung ausrechnen, das Integral über die Oberfläche vec E skalar multipliziert mit dem Flächenelement vec dA. Energie/Masse und auch die Ladung steckt im Feld! :O

... und was ist jetzt Psi, die Wellenfunktion der Quantenmechanik?

Klar doch - auch das EM-Feld !!! :O :O :O

Real- und Imaginärteil von PSi sind als elektrisches und 
magnetisches Feld zu interpretieren!

 Zweiköperkörperproblem 
 --------------------------------------------- 
 Wir setzen voraus:
 
 Die Lösung (für gebundene Systeme) ist eine Ellipse:
 
 rmin/rmax = (Halbachse a) * (1 +/- epsilon) 
 
 a = (rmax + rmin)/2 
 epsilon = (rmin - rmax)/(rmin + rmax)

 Wir wollen Gesamtenergie (E < 0) und Drehimplus L 
 aus rmin/rmax berechen. Wir berechnen rmin/rmax, 
 indem wir die zeitliche Ableitung von r null setzen.
 
 Wir finden rmin/rmax als Lösung einer quadratischen
 Gleichung für r.
 
 Zur Erinnerung:
 ----------------------
 A*x^2 + B*x + C = 0 
 => x = - B/2A +/- sqrt (B^2 - 4AC)/2A 
 
 
 I.) 
 PLanet (Masse m) und die Sonne (Masse M)  
 A:= E
 B:= GMm
 C:= - (1/2*L^2/m)

 a = - B/2A = - GMm/2E

 E = - GMm/2a < 0

 epsilon = - sqrt((GMm)^2 + 2EL^2/m)/(2Ea)

=  sqrt((GMm)^2 + 2EL^2/m)/(GMm)

=  sqrt(1 + 2EL^2/m/(GMm)^2)

II.) 
 Elektron (Ladung -e, Masse m) und der Kern (Ladung e)  
 A:= E
 B:= e^2
 C:= - (1/2*L^2/m)

 a(1 +/- epsilon) = - B/2A +/-sqrt(B^2 - 4*A*C)/2A

 a = - B/2A = - 1/(4pi eps0) e^2/2E

 E = - 1/(4pi eps0) e^2/2a  < 0

 epsilon = - sqrt((1/(4pi eps0) e^2)^2 + 2EL^2/m)/(2Ea)

=  sqrt((1/(4pi eps0) e^2)^2 + 2EL^2/m)/(1/(4pi eps0) e^2)

=  sqrt(1 + 2EL^2/m/(1/(4pi eps0) e^2)^2)

Einstein oder Planck? 

WIKIPEDIA 2020
Eine Glühwendel leuchtet bei ca. 700 °C rot, 
bei 2500 °C orange bis gelb.

Max Planck auf der ersten Solvay-Konferenz (1911) 
mit seinem Strahlungsgesetz im Hintergrund auf der 
Wandtafel Das plancksche Strahlungsgesetz gibt die 
Verteilung der elektromagnetischen Energie der 
Wärmestrahlung eines schwarzen Körpers in Abhängigkeit
von der Wellenlänge oder der Frequenz der Strahlung an.

Max Planck fand das Strahlungsgesetz im Jahr 1900 und 
bemerkte, dass eine Herleitung im Rahmen der klassischen
Physik nicht möglich ist.[1] 

Vielmehr erwies es sich als notwendig, ein neues Postulat
einzuführen, dem zufolge der Energieaustausch zwischen
Oszillatoren und dem elektromagnetischen Feld nicht
kontinuierlich, sondern in Form kleinster Energiepakete
(später als Quanten bezeichnet) stattfindet. 

Plancks Herleitung des Strahlungsgesetzes gilt daher heute
als die Geburtsstunde der Quantenphysik.

Die Gravitationslinse (Einsteinkreis):
---------------------------------------------  

M: Masse der Gravitationslinse 
r: Radius des Einsteinkreises 
L1: Entfernung Erde Linse 
L2: Entfernung Linse zu fernem Stern 

Der Radius des kreisförmigen Querschnitts durch 
die das Licht des fernen Sterns tritt, wenn es 
den Beobachter auf der Erde erreicht.

(C * M) / r = r/L1 + r/L2 

r = sqrt(C * M * L) 

C: Die Konstante C ist 
(2 * Gravitationskonstante)/c^2 
oder das doppelte davon
               4*G/c^2 
nach Einsteins ART.

In jedem Fall etwa eine Bogensekunde für einen 
sonnenähnlichen Stern.

c = Ausbreitungsgeschwindigkeit elektromagnetischer
    Wellen im Vakuum.
    
L ist der effektive Abstand L1*L2/(L1+L2)

Für stark unterschiedliche Werte L1 und L2 ist 
L näherungsweise das Minimum beider Werte. Für 
einen extrem fernen Stern gilt also L = L1.

Wirkungsquerschnitt den ein Photon durchdringen
muss, um die Erde erreichen zu können.

Ohne Gravitationslinse: 

                        pi*Reff^2 

(Reff ist der Radius des fernen Sterns am Ort der Linse)

Mit Linse

      (2*pi*r) * (2Reff) = 4*pi*Reff * sqrt(C*M*L)

Verstärkung (Verhältnis der Querschnitte):

          4 * sqrt(C*M*L)/Reff = 4 (r/Reff)


Berechnung aus dem Sternradius R

               Reff = L1/(L1+L2) * R = L/L2 * R 

Der Effekt ist also für sehr weit entfernte Sterne
noch größer. Die Verstärkung wird unendlich groß 
für unendlich weit entfernte Sterne!

Wie wahrscheinlich ist das?

Wir fragen, ob zwei Sterne in der selben Richtung
liegen, ihre Entfernung interessiert uns (zunächst)
nicht. Genauer fragen wir, ist der Abstand kleiner 
als eine Bogensekunde, die Ablenkung
des Lichts am Sternenrand, also die maximal mögliche 
Ablenkung durch einen Stern mit vergleicbaren 
Dimensionen wie unsere Sonne. 

Wir stellen uns die Sterne alle auf einer Kugel mit 
Radius R gleich eins vor. Die Sterne stellen wir uns als 
kleine Kreise mit Radius r vor. Wegen R = 1, ist r gleich 
dem Winkel im Bogenmaß.

Die Wahrscheinlichkeit, dass zwei zufällig gewählte 
Sterne, die gedachten Kreise mit Radius r überlappen,
ist das Verhältnis der Kreisfläche (pi r^2) zur 
Gesamtfläche der Kugel (4 pi).

Wahrscheinlichkeit für Überlappung innerhalb einer 
Bogensekunde:

also Winkel (Bogenmaß) im Quadrat geteilt durch vier.

Für eine Bogensekunde erhalten wir etwa

0,6 mal 10^{-11} also 0,6 durch 100 Milliarden.

Aha, das hebt sich gerade auf mit der Zahl der 
Sterne, die in unserer Milchstraße vermutet werden.

Es gibt also definitiv Sterne, die sich bis auf eine 
Bogensekunde, die Ablenkung am Sternenrand annähern.

Es sind nicht immer die gleichen Sterne, weil sich 
die Sterne bewegen, wenn auch nur minimal, aber eine 
Bogensekunde können sie sich durchaus bewegen, durch 
die Bewegung des Boebachters (Erde) und der Sterne.

Wenn wir uns eine bekannten Stern, etwa den Sirius
herauspicken, können wir immer wieder Sterne hinter
dem Sirius beobachten, dessen Licht um mindestens eine 
Bogensekunde abgelenkt wird. Es entstehen dann zwei 
Bilder des fernen Sterns, eines davon direkt neben
dem Sirius. 

----------------------------------------------------------
In cryptography, a Schnorr signature is a digital signature
produced by the Schnorr signature algorithm that was described 
by Claus Schnorr. It is a digital signature scheme known for its
simplicity,[1] among the first whose security is based on the 
intractability of certain discrete logarithm problems.[1] 

It is efficient and generates short signatures.[1]

It was covered by U.S. Patent 4,995,082 which expired in February 2008.

EINSTEIN und der Planet
meine Simulationsrechnung zur Periheldrehung
---------------------------------------------
e = 0.1
dt = 0.00001
vy = 1.0*(1.0+e)
vx = 0.0
c = 100.0
import math
gamma = 1.0 / math.sqrt(1.0-(vx*vx + vy*vy)/(c*c))
px = vx * gamma
py = vy * gamma
x = -(1.0-e)
y = 0.0
t = 0.0
s0 = px*x + py*y
y0 = y
t0 = 0
while t < 30:
    t += dt      
    gamma = 1.0 / math.sqrt(1.0-(vx*vx + vy*vy)/(c*c))
    r3 = math.sqrt(x*x + y*y)**3
    px -= gamma*(x/r3)*dt
    py -= gamma*(y/r3)*dt
    vx = px / gamma
    vy = py / gamma
    x += vx * dt 
    y += vy * dt
    if y0*y < 0.0:
       print("y = 0 ", t)
       t0 = t
    if s0*(px*x + py*y) < 0.0:
       print("s = 0 ", t , "relativ ", (t - t0)/t)
    s0 = px*x + py*y
    y0 = y
 ------------------------------------------------------
s = 0  9.255949999818759 relativ  0.00013612865237787276               
y = 0  12.340059999702001                                              
s = 0  12.341109999701962 relativ  8.508148780665653e-05               
y = 0  15.424489999585232                                              
s = 0  15.426499999585156 relativ  0.00013029527112293508              
y = 0  18.51008999946842                                               
s = 0  18.51166999946836 relativ  8.535156471488316e-05                
y = 0  21.59429999935166                                               
s = 0  21.597059999351554 relativ  0.00012779517211964874              
y = 0  24.680119999234837                                              
s = 0  24.682219999234757 relativ  8.508148780723965e-05               
y = 0  27.764099999118084                                              
s = 0  27.76760999911795 relativ  0.000126406269750209 

beta^2 =  0.00012099999970061421                                       
s = 0  18.51166999946836 relativ  0.00010431857883784591               
y = 0  21.59429999935166                                               
beta^2 =  8.467349865399473e-05                                        
s = 0  21.597059999351554 relativ  0.00010929967448445127              
y = 0  24.680119999234837                                              
beta^2 =  0.00012099999959473705                                       
s = 0  24.682219999234757 relativ  0.0001039884847494153               
y = 0  27.764099999118084                                              
beta^2 =  8.467349873350413e-05                                        
s = 0  27.76760999911795 relativ  0.00010811178482180875        
'''
#Generate the private key from a password
privateKey = h( 'passwordX' ) 

#Generate the base point from another password
x = h("password 1234567")
if pow(x**3 + ecc_a*x + ecc_b, (ecc_prime-1)//2, 
   ecc_prime) != 1:
   x = ecc_prime - x 
y = pow( x**3 + ecc_a*x + ecc_b, (ecc_prime+1)//4,
    ecc_prime)
P = [ x , y ]
# To get a base point with prime order
P = ECHASH.mulP(P, 4)

print("The base point is: \n P = ", P)

publicKey = ECHASH.mulP(P, privateKey)

print("The public key is the point: ")
print ("publicKey = ", publicKey)
sig = ECHASH.signSchnorr(P, message, privateKey)
print("The signature is: ")
print("sig = ", sig)
#Verification
P1 = ECHASH.mulP(P, sig['s'])
P2 = ECHASH.mulP(publicKey, sig['e'])
r =  ECHASH.addP(P1, P2)[0]
assert(h(str(r)+message) % ecc_n == sig['e'])
'''
   ECDSA_N with sig['r'] used as NONCE

   This algorithm is equivalent to Schnorr's signature.
   We can apply the same public and private key and 
   the same message.
   
   In cryptography, a nonce is an arbitrary number 
   that can be used just once in a cryptographic 
   communication. It is similar in spirit to a nonce word,
   hence the name. It is often a random or pseudo-random
   number issued in an authentication protocol to ensure
   that old communications cannot be reused in replay attacks.
   They can also be useful as initialization vectors and in
   cryptographic hash functions.
'''
sig = ECHASH.ECDSA_N(P, message, privateKey)
print("The signature is: ")
print("sig = ",  sig)

#Verification
z = h(message + str(sig['r'])) 
sinv = pow(sig['s'], ecc_n-2, ecc_n)
P1 = ECHASH.mulP(P, sinv * z)
P2 = ECHASH.mulP(publicKey, sinv * sig['r'])
r =  ECHASH.addP(P1, P2)[0]
assert( r % ecc_n == sig['r'] )
'''
e = 0.1
dt = 0.0001
vy = 1.0*(1.0+e)
vx = 0.0
c = 100.0
import math
v = math.sqrt(vx*vx + vy*vy)
print ("beta^2 = ", (v/c)**2)

mass = 1.0 / math.sqrt(1.0 - (v/c)**2)
px = vx * mass
py = vy * mass
x = -(1.0-e)
y = 0.0
t = 0.0
s0 = px*x + py*y
y0 = y
t0 = 0
while t < 30:
    t += dt
    v = math.sqrt(vx*vx + vy*vy)
    mass = 1.0 / math.sqrt(1.0-(v/c)**2)
    r = math.sqrt(x*x + y*y)
    r3 = r*r*r
    px -= mass * (x/r3)*dt
    py -= mass * (y/r3)*dt
    vx = px / mass
    vy = py / mass
    x += vx * dt 
    y += vy * dt
    if y0*y < 0.0:
       print("y = 0 ", t)
       t0 = t
    if s0*(px*x + py*y) < 0.0:
       winkel = ((t-t0) * v) / r
       print("beta^2 = ",(v/c)**2)
       print("s = 0 ", t , "relativ ", (winkel)/t)
    s0 = px*x + py*y
    y0 = y
A prime greater than 2^141                                               
p =  256720937847416416719320263092896073801153427                       
The base point is:                                                       
 P =  [92078480886683387215913498910810247905170284,
 40947367689051583059937238585334772307041483]                                              
The public key is the point:                                             
publicKey =  [251042657009257704742720072719895026687717513,
198422889824086808578675441164155470189537528]                                     
The signature is:                                                        
sig =  {'e': 25075537265813821447485672688527593283964188, 's': 4319180  
2236957660065656780049302065461920213}                                   
The signature is:                                                        
sig =  {'r': 52828890101695226488986927429950190597554887,
's': 31197238196584488004113837783551025028508900}                                       
'''
